# -*- coding: utf-8 -*-
"""Sentiment_stockprediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R3sqgOZ5Y6161hgaC3QUaiiEDe5DgUjH
"""

!pip install vaderSentiment

for stock in stocks:
    news = yf.Ticker(stock).news
    if news:
        sentiment[stock] = sum([get_sentiment(article['summary'] if 'summary' in article else article['title']) for article in news]) / len(news)
    else:
        sentiment[stock] = 0.0

from datetime import datetime, timedelta
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from sklearn.linear_model import LinearRegression

# Define the stocks to analyze
stocks = ['0700.hk', '0020.hk', '0293.hk']

# Define the sentiment analyzer
analyzer = SentimentIntensityAnalyzer()

# Define a function to get the sentiment of a piece of text
def get_sentiment(text):
    return analyzer.polarity_scores(text)['compound']

# Define the number of days to look back
lookback_days = 30

# Get the historical data for each stock
data = {}
for stock in stocks:
    ticker = yf.Ticker(stock)
    df = ticker.history(period='max')
    df = df[-lookback_days:]
    data[stock] = df

# Calculate the sentiment for each stock
sentiment = {}
for stock in stocks:
    news = yf.Ticker(stock).news
    if news:
        sentiment[stock] = sum([get_sentiment(article['summary'] if 'summary' in article else article['title']) for article in news]) / len(news)
    else:
        sentiment[stock] = 0.0

# Prepare the data for training the model
X = []
y = []
for stock in stocks:
    df = data[stock]
    for i in range(len(df)):
        if i == 0:
            X.append([sentiment[stock], 0])
        else:
            X.append([sentiment[stock], df['Close'][i-1]])
        y.append(df['Close'][i])

# Train the linear regression model
model = LinearRegression()
model.fit(X, y)

# Predict the next day's stock prices
for stock in stocks:
    sentiment_score = sentiment[stock]
    df = data[stock]
    if len(df) > 0:
        prev_close = df['Close'][-1]
        next_close = model.predict([[sentiment_score, prev_close]])[0]
        print(f'Predicted price of {stock} tomorrow: {next_close:.2f}')

for stock in stocks:
    news = yf.Ticker(stock).news
    print(f"News for {stock}: {news}")

for stock in stocks:
    news = yf.Ticker(stock).news
    if news:
        filtered_news = [article for article in news if 'summary' in article]
        if filtered_news:
            sentiment[stock] = sum([get_sentiment(article['summary']) for article in filtered_news]) / len(filtered_news)
        else:
            sentiment[stock] = 0.0
    else:
        sentiment[stock] = 0.0

import yfinance as yf
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer

# Define the function to get sentiment score
def get_sentiment(text):
    analyzer = SentimentIntensityAnalyzer()
    return analyzer.polarity_scores(text)['compound']

# Define the stocks to track
stocks = ['AAPL', 'GOOGL', 'AMZN', 'MSFT', 'FB']

# Get the sentiment score for each stock
sentiment = {}
for stock in stocks:
    news = yf.Ticker(stock).news
    if news:
        # Filter out articles without a summary
        news_with_summary = [article for article in news if 'summary' in article]
        if news_with_summary:
            sentiment[stock] = sum([get_sentiment(article['summary']) for article in news_with_summary]) / len(news_with_summary)
        else:
            sentiment[stock] = 0.0
    else:
        sentiment[stock] = 0.0

# Print the sentiment of each stock
print(sentiment)

# Get the historical data for each stock
data = yf.download(stocks, start="2022-01-01", end="2022-03-31")

# Select the 'Close' price
close = data['Close']

# Calculate the daily return for each stock
daily_return = close.pct_change()

# Merge the sentiment and daily return data
df = daily_return.merge(pd.DataFrame(sentiment.items(), columns=['Symbol', 'Sentiment']), left_index=True, right_on='Symbol')

# Train a Random Forest Regression model
from sklearn.ensemble import RandomForestRegressor

X = df[['Sentiment']]
y = df.iloc[:,1:-1]

rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X, y)

# Make predictions
new_sentiment = pd.DataFrame({'Sentiment': [-0.5, 0.2, 0.8]})
predictions = rf_model.predict(new_sentiment)

print(predictions)